{
    "new var": {
        "prefix": "var",
        "body": [ "local ${1:newvar} = ${2:}" ]
    },

    "new var table": {
        "prefix": "var table",
        "body": [ "local ${1:newtable} = {${2:}}" ]
    },

    "new function": {
        "prefix": "func",
        "body": [ "function ${1:newfunc}() ${2:} end" ]
    },

    "new local function": {
        "prefix": "func loc",
        "body": [ "local function ${1:newfunc}() ${2:} end" ]
    },

    "new anonymous function": {
        "prefix": "func anon",
        "body": [ "function() ${1:} end" ]
    },

    "new if": {
        "prefix": "if",
        "body": [
            "if ${1:cond} then",
            "\t${2:}",
            "end"
        ]
    },

    "new ternary": {
        "prefix": "ternary",
        "body": [ "${1:cond} and ${2:\"a\"} or ${3:\"b\"}" ]
    },

    "for each": {
        "prefix": "for each",
        "body": [
            "for key, value in pairs(${1:table}) do",
            "\t${2:}",
            "end"
        ]
    },

    "return": {
        "prefix": "return",
        "body": [ "return ${1:}" ]
    },

    "lua print": {
        "prefix": "print",
        "body": [ "print(${1:\"Hello!\"})" ]
    },

    "lua module": {
        "prefix": "module",
        "body": [
            "local M = {}",
            "",
            "${1:}",
            "",
            "--------",
            "return M"
        ]
    },

    "lua type annotation param": {
        "prefix": "type annotation param",
        "body": ["---@param ${1:} ${2:}"]
    },

    "lua type annotation return": {
        "prefix": "type annotation return",
        "body": ["---@return ${1:}"]
    },

    "nvim print inspect": {
        "prefix": "print inspect",
        "body": [ "print(vim.inspect(${1:}))" ]
    },

    "nvim notify": {
        "prefix": "notify",
        "body": "vim.notify(\"${1:notif}\", vim.log.levels.${2:INFO})"
    },

    "nvim inspect": {
        "prefix": "inspect",
        "body": "vim.inspect(${1:})"
    },

    "nvim flatten table": {
        "prefix": "flatten table",
        "body": [
            "local table = vim.iter({",
                "\t${1:table1}",
                "\t${2:table2}",
            "}):flatten(1):totable()"
        ]
    },

    "get nvim cwd": {
        "prefix": "nvim cwd",
        "body": [ "vim.fn.getcwd()" ]
    },

    "get home dir": {
        "prefix": "get home dir",
        "body": "os.getenv(\"HOME\")"
    },

    "get nvim file path": {
        "prefix": "get nvim file path",
        "body": [ "vim.fn.expand(\"%:p\")" ]
    },

    "get nvim file dir": {
        "prefix": "get nvim file dir",
        "body": [ "vim.fn.expand(\"%:p:h\")" ]
    },

    "get nvim filename": {
        "prefix": "get nvim filename",
        "body": [ "vim.fn.expand(\"%:p:t\")" ]
    },

    "get nvim filetype": {
        "prefix": "get nvim filetype",
        "body": [ "vim.bo.filetype" ]
    },


    "create nvim buffer": {
        "prefix": "create nvim buf",
        "body": [ "vim.api.nvim_create_buf(false, true)" ]
    },

    "get nvim current buffer": {
        "prefix": "get nvim curr buf",
        "body": [ "vim.api.nvim_get_current_buf()" ]
    },

    "get nvim buffer path": {
        "prefix": "get nvim buf path",
        "body": [ "vim.api.nvim_buf_get_name(0)" ]
    },

    "get nvim buffertype": {
        "prefix": "get nvim buftype",
        "body": [ "vim.bo.buftype" ]
    },

    "set nvim buffer var": {
        "prefix": "set nvim buffer var",
        "body": [ "vim.b[buf].${1:}" ]
    },


    "set nvim global var": {
        "prefix": "set nvim global var",
        "body": [ "vim.g.${1:}" ]
    },


    "get nvim mode": {
        "prefix": "get nvim mode",
        "body": [ "vim.fn.mode()" ]
    },

    "get nvim cursor position": {
        "prefix": "get nvim cursor pos",
        "body": [ "vim.api.nvim_win_get_cursor(0)" ]
    },

    "set nvim cursor position": {
        "prefix": "set nvim cursor pos",
        "body": [ "vim.api.nvim_win_set_cursor(0, cpos)" ]
    },

    "get nvim region": {
        "prefix": "get nvim region",
        "body": [
            "vim.fn.getregion(${1:startpos}, ${2:endpos})[1]"
        ]
    },

    "get nvim char under cursor": {
        "prefix": "get nvim char under cursor",
        "body": [
            "vim.fn.getregion(vim.fn.getpos('.'), vim.fn.getpos('.'))[1]"
        ]
    },

    "get nvim visual selection text": {
        "prefix": "get nvim visual selection text",
        "body": [
            "vim.fn.getregion(vim.fn.getpos(\".\"), vim.fn.getpos(\"v\"))[1]"
        ]
    },

    "set nvim text at position": {
        "prefix": "set nvim text at position",
        "body": [
            "vim.api.nvim_buf_set_text(0,",
            "    startrow, startcol,",
            "    endrow,   endcol,",
            "    {\"text\"}",
            ")"
        ]
    },


    "set nvim keymap": {
        "prefix": "set nvim keymap",
        "body": [
            "vim.keymap.set(\"${1:n}\", \"${2:<key>}\", \"${3:}\")"
        ]
    },

    "vim cmd": {
        "prefix": "vim.cmd",
        "body": [ "vim.cmd(\"${1:}\")" ]
    },

    "new nvim user command": {
        "prefix": "new nvim user command",
        "body": [
            "vim.api.nvim_create_user_command(\"${1:NewUserCmd}\", function()",
                "\t${2:}",
                "end, {})"
        ],
        "description": ""
    },

    "new nvim autocommand": {
        "prefix": "new nvim autocommand",
        "body": [
            "vim.api.nvim_create_autocmd('${1:BufEnter}', {",
                "\tgroup = 'UserAutoCmds',",
                "\tpattern = '*',",
                "\tcallback = function()",
                "\t\t${0:}",
                "\tend,",
                "})"
        ]
    },

    "new nvim user autocmd group": {
        "prefix": "new nvim user autocmd group",
        "body": [
            "vim.api.nvim_create_augroup('NewUserAutoCmdGroup', { clear = true })"
        ]
    },


    "vim ui input": {
        "prefix": "vim ui input",
        "body": [
            "vim.ui.input({",
            "    prompt=\"${1:Input}:\" default=\"${2:default}\" completion=\"file\",",
            "},",
            "function(input)",
            "    vim.api.nvim_command(\"redraw\") -- Hide prompt",
            "    if input == nil then",
            "        vim.notify(\"Canceled\", vim.log.levels.INFO) return",
            "    end",
            "    if input == \"\" then",
            "        print(\"input empty!\") return",
            "    end",
            "",
            "    ${0:}",
            "end)"
        ]
    },

    "nvim keymap cmd": {
        "prefix": "keymap cmd",
        "body": [
            "\"<Cmd>${1:}<CR>\""
        ]
    }

}


